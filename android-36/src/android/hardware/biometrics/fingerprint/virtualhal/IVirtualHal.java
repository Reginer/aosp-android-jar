/*
 * This file is auto-generated.  DO NOT MODIFY.
 * Using: out/host/linux-x86/bin/aidl --lang=java -Weverything -Wno-missing-permission-annotation -t --min_sdk_version platform_apis -pout/soong/.intermediates/hardware/interfaces/biometrics/common/aidl/android.hardware.biometrics.common_interface/4/preprocessed.aidl -pout/soong/.intermediates/hardware/interfaces/keymaster/aidl/android.hardware.keymaster_interface/4/preprocessed.aidl -pout/soong/.intermediates/hardware/interfaces/biometrics/fingerprint/aidl/android.hardware.biometrics.fingerprint_interface/4/preprocessed.aidl --ninja -d out/soong/.intermediates/hardware/interfaces/biometrics/fingerprint/aidl/android.hardware.biometrics.fingerprint.virtualhal-java-source/gen/android/hardware/biometrics/fingerprint/virtualhal/IVirtualHal.java.d -o out/soong/.intermediates/hardware/interfaces/biometrics/fingerprint/aidl/android.hardware.biometrics.fingerprint.virtualhal-java-source/gen -Nhardware/interfaces/biometrics/fingerprint/aidl hardware/interfaces/biometrics/fingerprint/aidl/android/hardware/biometrics/fingerprint/virtualhal/IVirtualHal.aidl
 *
 * DO NOT CHECK THIS FILE INTO A CODE TREE (e.g. git, etc..).
 * ALWAYS GENERATE THIS FILE FROM UPDATED AIDL COMPILER
 * AS A BUILD INTERMEDIATE ONLY. THIS IS NOT SOURCE CODE.
 */
package android.hardware.biometrics.fingerprint.virtualhal;
/** @hide */
public interface IVirtualHal extends android.os.IInterface
{
  /** Default implementation for IVirtualHal. */
  public static class Default implements android.hardware.biometrics.fingerprint.virtualhal.IVirtualHal
  {
    /** Set Fingerprint Virtual HAL behavior parameters */
    /**
     * setEnrollments
     * 
     * Set the ids of the fingerprints that were currently enrolled in the Virtual HAL,
     * 
     * @param ids ids can contain 1 or more ids, each must be larger than 0
     */
    @Override public void setEnrollments(int[] id) throws android.os.RemoteException
    {
    }
    /**
     * setEnrollmentHit
     * 
     * Set current fingerprint enrollment ids in Fingerprint Virtual HAL,
     * 
     * @param ids ids can contain 1 or more ids, each must be larger than 0
     */
    @Override public void setEnrollmentHit(int hit_id) throws android.os.RemoteException
    {
    }
    /**
     * setNextEnrollment
     * 
     * Set the next enrollment behavior
     * 
     * @param next_enrollment specifies enrollment id, progress stages and final result
     */
    @Override public void setNextEnrollment(android.hardware.biometrics.fingerprint.virtualhal.NextEnrollment next_enrollment) throws android.os.RemoteException
    {
    }
    /**
     * setAuthenticatorId
     * 
     * Set authenticator id in virtual HAL, the id is returned in ISession#getAuthenticatorId() call
     * 
     * @param id authenticator id value, only applied to the sensor with SensorStrength::STRONG.
     */
    @Override public void setAuthenticatorId(long id) throws android.os.RemoteException
    {
    }
    /**
     * setChallenge
     * 
     * Set the challenge generated by the virtual HAL, which is returned in
     * ISessionCallback#onChallengeGenerated()
     * 
     * @param challenge
     */
    @Override public void setChallenge(long challenge) throws android.os.RemoteException
    {
    }
    /**
     * setOperationAuthenticateFails
     * 
     * Set whether to force authentication to fail. If true, the virtual hal will report failure on
     * authentication attempt until it is set to false
     * 
     * @param fail  if true, then the next authentication will fail
     */
    @Override public void setOperationAuthenticateFails(boolean fail) throws android.os.RemoteException
    {
    }
    /**
     * setOperationAuthenticateLatency
     * 
     * Set authentication latency in the virtual hal in a fixed value (single element) or random
     * values (two elements representing the bound values)
     * The latency simulates the delay from the time framework requesting HAL to authetication to
     * the time when HAL is ready to perform authentication operations.
     * 
     * This method fails with STATUS_INVALID_PARAMETERS if the passed-in array falls in any of
     * the following conditions
     *   1. the array contains no element
     *   2. the array contains more than two elements
     *   3. the array contains any negative value
     * The accompanying error message gives more detail
     * 
     * @param latencyMs[]  value(s) are in milli-seconds
     */
    @Override public void setOperationAuthenticateLatency(int[] latencyMs) throws android.os.RemoteException
    {
    }
    /**
     * setOperationAuthenticateDuration
     * 
     * Set authentication duration covering the HAL authetication from start to end, including
     * fingerprint capturing, and matching, acquired info reporting. In case a sequence of acquired
     * info code are specified via setOperationAuthenticateAcquired(), the reporting is evenly
     * distributed over the duration.
     * 
     * This method fails with STATUS_INVALID_PARAMETERS if the passed-in value is negative
     * 
     * @param duration  value is in milli-seconds
     */
    @Override public void setOperationAuthenticateDuration(int durationMs) throws android.os.RemoteException
    {
    }
    /**
     * setOperationAuthenticateError
     * 
     * Force authentication to error out for non-zero error
     * Check hardware/interfaces/biometrics/fingerprint/aidl/default/README.md for valid error codes
     * 
     * @param error if error < 1000
     *                  non-vendor error
     *              else
     *                  vendor error
     */
    @Override public void setOperationAuthenticateError(int error) throws android.os.RemoteException
    {
    }
    /**
     * setOperationAuthenticateAcquired
     * 
     * Set one of more acquired info codes for the virtual hal to report during authentication
     * Check hardware/interfaces/biometrics/fingerprint/aidl/default/README.md for valid acquired
     * info codes
     * 
     * @param acquired[], one or more acquired info codes
     */
    @Override public void setOperationAuthenticateAcquired(android.hardware.biometrics.fingerprint.virtualhal.AcquiredInfoAndVendorCode[] acquired) throws android.os.RemoteException
    {
    }
    /**
     * setOperationEnrollError
     * 
     * Force enrollment operation to error out for non-zero error
     * Check hardware/interfaces/biometrics/fingerprint/aidl/default/README.md for valid error codes
     * 
     * @param error if error < 1000
     *                  non-vendor error
     *              else
     *                  vendor error
     */
    @Override public void setOperationEnrollError(int error) throws android.os.RemoteException
    {
    }
    /**
     * setOperationEnrollLatency
     * 
     * Set enrollment latency in the virtual hal in a fixed value (single element) or random
     * values (two elements representing the bound values)
     * The latency simulates the delay from the time framework requesting HAL to enroll to the
     * time when HAL is ready to perform enrollment operations.
     * 
     * This method fails with STATUS_INVALID_PARAMETERS if the passed-in array falls in any of
     * the following conditions
     *   1. the array contains no element
     *   2. the array contains more than two elements
     *   3. the array contains any negative value
     * The accompanying error message gives more detail
     * 
     * @param latencyMs[]  value(s) are in milli-seconds
     */
    @Override public void setOperationEnrollLatency(int[] latencyMs) throws android.os.RemoteException
    {
    }
    /**
     * setOperationDetectInteractionLatency
     * 
     * Set detect interaction latency in the virtual hal in a fixed value (single element) or random
     * values (two elements representing the bound values)
     * The latency simulates the delay from the time framework requesting HAL to detect interaction
     * to the time when HAL is ready to perform detect interaction operations.
     * 
     * This method fails with STATUS_INVALID_PARAMETERS if the passed-in array falls in any of
     * the following conditions
     *   1. the array contains no element
     *   2. the array contains more than two elements
     *   3. the array contains any negative value
     * The accompanying error message gives more detail
     * 
     * @param latencyMs[]  value(s) are in milli-seconds
     */
    @Override public void setOperationDetectInteractionLatency(int[] latencyMs) throws android.os.RemoteException
    {
    }
    /**
     * setOperationDetectInteractionError
     * 
     * Force detect interaction operation to error out for non-zero error
     * Check hardware/interfaces/biometrics/fingerprint/aidl/default/README.md for valid error codes
     * 
     * @param error if error < 1000
     *                  non-vendor error
     *              else
     *                  vendor error
     */
    @Override public void setOperationDetectInteractionError(int error) throws android.os.RemoteException
    {
    }
    /**
     * setOperationDetectInteractionDuration
     * 
     * Set detect interaction duration covering the HAL authetication from start to end, including
     * fingerprint detect and acquired info reporting. In case a sequence of acquired info code are
     * specified via setOperationDetectInteractionAcquired(), the reporting is evenly distributed
     * over the duration.
     * 
     * This method fails with STATUS_INVALID_PARAMETERS if the passed-in value is negative
     * 
     * @param duration  value is in milli-seconds
     */
    @Override public void setOperationDetectInteractionDuration(int durationMs) throws android.os.RemoteException
    {
    }
    /**
     * setOperationDetectInteractionAcquired
     * 
     * Set one of more acquired info codes for the virtual hal to report during detect interaction
     * Check hardware/interfaces/biometrics/fingerprint/aidl/default/README.md for valid acquired
     * info codes
     * 
     * @param acquired[], one or more acquired info codes
     */
    @Override public void setOperationDetectInteractionAcquired(android.hardware.biometrics.fingerprint.virtualhal.AcquiredInfoAndVendorCode[] acquired) throws android.os.RemoteException
    {
    }
    /**
     * setLockout
     * 
     * Whether to force to lockout on authentcation operation. If true, the virtual hal will report
     * permanent lockout in processing authentication requrest, regardless of whether
     * setLockoutEnable(true) is called or not.
     * 
     * @param lockout, set to true if lockout is desired
     */
    @Override public void setLockout(boolean lockout) throws android.os.RemoteException
    {
    }
    /**
     * setLockoutEnable
     * 
     * Whether to enable authentication-fail-based lockout tracking or not. The lock tracking
     * includes both timed-based (aka temporary) lockout and permanent lockout.
     * 
     * @param enable, set true to enable the lockout tracking
     */
    @Override public void setLockoutEnable(boolean enable) throws android.os.RemoteException
    {
    }
    /**
     * setLockoutTimedThreshold
     * 
     * Set the number of consecutive authentication failures that triggers the timed-based lock to
     * occur
     * 
     * This method fails with STATUS_INVALID_PARAMETERS if the passed-in value is negative
     * 
     * @param threshold, the number of consecutive failures
     */
    @Override public void setLockoutTimedThreshold(int threshold) throws android.os.RemoteException
    {
    }
    /**
     * setLockoutTimedDuration
     * 
     * Set the duration to expire timed-based lock during which there is no authentication failure
     * 
     * This method fails with STATUS_INVALID_PARAMETERS if the passed-in value is negative
     * 
     * @param duration, in milli-seconds
     */
    @Override public void setLockoutTimedDuration(int durationMs) throws android.os.RemoteException
    {
    }
    /**
     * setLockoutPermanentThreshold
     * 
     * Set the number of consecutive authentication failures that triggers the permanent lock to
     * occur
     * 
     * This method fails with STATUS_INVALID_PARAMETERS if the passed-in value is negative
     * 
     * @param threshold, the number of consecutive failures
     */
    @Override public void setLockoutPermanentThreshold(int threshold) throws android.os.RemoteException
    {
    }
    /**
     * resetConfigurations
     * 
     * Reset all virtual hal configurations to default values
     */
    @Override public void resetConfigurations() throws android.os.RemoteException
    {
    }
    /**
     * The following functions are used to configure Fingerprint Virtual HAL sensor properties
     *  refer to SensorProps.aidl and CommonProps.aidl for details of each property
     */
    @Override public void setType(byte type) throws android.os.RemoteException
    {
    }
    @Override public void setSensorId(int id) throws android.os.RemoteException
    {
    }
    @Override public void setSensorStrength(byte strength) throws android.os.RemoteException
    {
    }
    @Override public void setMaxEnrollmentPerUser(int max) throws android.os.RemoteException
    {
    }
    @Override public void setSensorLocation(android.hardware.biometrics.fingerprint.SensorLocation loc) throws android.os.RemoteException
    {
    }
    @Override public void setNavigationGesture(boolean v) throws android.os.RemoteException
    {
    }
    @Override public void setDetectInteraction(boolean v) throws android.os.RemoteException
    {
    }
    @Override public void setDisplayTouch(boolean v) throws android.os.RemoteException
    {
    }
    @Override public void setControlIllumination(boolean v) throws android.os.RemoteException
    {
    }
    @Override public android.hardware.biometrics.fingerprint.IFingerprint getFingerprintHal() throws android.os.RemoteException
    {
      return null;
    }
    @Override
    public android.os.IBinder asBinder() {
      return null;
    }
  }
  /** Local-side IPC implementation stub class. */
  public static abstract class Stub extends android.os.Binder implements android.hardware.biometrics.fingerprint.virtualhal.IVirtualHal
  {
    /** Construct the stub and attach it to the interface. */
    @SuppressWarnings("this-escape")
    public Stub()
    {
      this.attachInterface(this, DESCRIPTOR);
    }
    /**
     * Cast an IBinder object into an android.hardware.biometrics.fingerprint.virtualhal.IVirtualHal interface,
     * generating a proxy if needed.
     */
    public static android.hardware.biometrics.fingerprint.virtualhal.IVirtualHal asInterface(android.os.IBinder obj)
    {
      if ((obj==null)) {
        return null;
      }
      android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
      if (((iin!=null)&&(iin instanceof android.hardware.biometrics.fingerprint.virtualhal.IVirtualHal))) {
        return ((android.hardware.biometrics.fingerprint.virtualhal.IVirtualHal)iin);
      }
      return new android.hardware.biometrics.fingerprint.virtualhal.IVirtualHal.Stub.Proxy(obj);
    }
    @Override public android.os.IBinder asBinder()
    {
      return this;
    }
    /** @hide */
    public static java.lang.String getDefaultTransactionName(int transactionCode)
    {
      switch (transactionCode)
      {
        case TRANSACTION_setEnrollments:
        {
          return "setEnrollments";
        }
        case TRANSACTION_setEnrollmentHit:
        {
          return "setEnrollmentHit";
        }
        case TRANSACTION_setNextEnrollment:
        {
          return "setNextEnrollment";
        }
        case TRANSACTION_setAuthenticatorId:
        {
          return "setAuthenticatorId";
        }
        case TRANSACTION_setChallenge:
        {
          return "setChallenge";
        }
        case TRANSACTION_setOperationAuthenticateFails:
        {
          return "setOperationAuthenticateFails";
        }
        case TRANSACTION_setOperationAuthenticateLatency:
        {
          return "setOperationAuthenticateLatency";
        }
        case TRANSACTION_setOperationAuthenticateDuration:
        {
          return "setOperationAuthenticateDuration";
        }
        case TRANSACTION_setOperationAuthenticateError:
        {
          return "setOperationAuthenticateError";
        }
        case TRANSACTION_setOperationAuthenticateAcquired:
        {
          return "setOperationAuthenticateAcquired";
        }
        case TRANSACTION_setOperationEnrollError:
        {
          return "setOperationEnrollError";
        }
        case TRANSACTION_setOperationEnrollLatency:
        {
          return "setOperationEnrollLatency";
        }
        case TRANSACTION_setOperationDetectInteractionLatency:
        {
          return "setOperationDetectInteractionLatency";
        }
        case TRANSACTION_setOperationDetectInteractionError:
        {
          return "setOperationDetectInteractionError";
        }
        case TRANSACTION_setOperationDetectInteractionDuration:
        {
          return "setOperationDetectInteractionDuration";
        }
        case TRANSACTION_setOperationDetectInteractionAcquired:
        {
          return "setOperationDetectInteractionAcquired";
        }
        case TRANSACTION_setLockout:
        {
          return "setLockout";
        }
        case TRANSACTION_setLockoutEnable:
        {
          return "setLockoutEnable";
        }
        case TRANSACTION_setLockoutTimedThreshold:
        {
          return "setLockoutTimedThreshold";
        }
        case TRANSACTION_setLockoutTimedDuration:
        {
          return "setLockoutTimedDuration";
        }
        case TRANSACTION_setLockoutPermanentThreshold:
        {
          return "setLockoutPermanentThreshold";
        }
        case TRANSACTION_resetConfigurations:
        {
          return "resetConfigurations";
        }
        case TRANSACTION_setType:
        {
          return "setType";
        }
        case TRANSACTION_setSensorId:
        {
          return "setSensorId";
        }
        case TRANSACTION_setSensorStrength:
        {
          return "setSensorStrength";
        }
        case TRANSACTION_setMaxEnrollmentPerUser:
        {
          return "setMaxEnrollmentPerUser";
        }
        case TRANSACTION_setSensorLocation:
        {
          return "setSensorLocation";
        }
        case TRANSACTION_setNavigationGesture:
        {
          return "setNavigationGesture";
        }
        case TRANSACTION_setDetectInteraction:
        {
          return "setDetectInteraction";
        }
        case TRANSACTION_setDisplayTouch:
        {
          return "setDisplayTouch";
        }
        case TRANSACTION_setControlIllumination:
        {
          return "setControlIllumination";
        }
        case TRANSACTION_getFingerprintHal:
        {
          return "getFingerprintHal";
        }
        default:
        {
          return null;
        }
      }
    }
    /** @hide */
    public java.lang.String getTransactionName(int transactionCode)
    {
      return this.getDefaultTransactionName(transactionCode);
    }
    @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException
    {
      java.lang.String descriptor = DESCRIPTOR;
      if (code >= android.os.IBinder.FIRST_CALL_TRANSACTION && code <= android.os.IBinder.LAST_CALL_TRANSACTION) {
        data.enforceInterface(descriptor);
      }
      if (code == INTERFACE_TRANSACTION) {
        reply.writeString(descriptor);
        return true;
      }
      switch (code)
      {
        case TRANSACTION_setEnrollments:
        {
          int[] _arg0;
          _arg0 = data.createIntArray();
          data.enforceNoDataAvail();
          this.setEnrollments(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setEnrollmentHit:
        {
          int _arg0;
          _arg0 = data.readInt();
          data.enforceNoDataAvail();
          this.setEnrollmentHit(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setNextEnrollment:
        {
          android.hardware.biometrics.fingerprint.virtualhal.NextEnrollment _arg0;
          _arg0 = data.readTypedObject(android.hardware.biometrics.fingerprint.virtualhal.NextEnrollment.CREATOR);
          data.enforceNoDataAvail();
          this.setNextEnrollment(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setAuthenticatorId:
        {
          long _arg0;
          _arg0 = data.readLong();
          data.enforceNoDataAvail();
          this.setAuthenticatorId(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setChallenge:
        {
          long _arg0;
          _arg0 = data.readLong();
          data.enforceNoDataAvail();
          this.setChallenge(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setOperationAuthenticateFails:
        {
          boolean _arg0;
          _arg0 = data.readBoolean();
          data.enforceNoDataAvail();
          this.setOperationAuthenticateFails(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setOperationAuthenticateLatency:
        {
          int[] _arg0;
          _arg0 = data.createIntArray();
          data.enforceNoDataAvail();
          this.setOperationAuthenticateLatency(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setOperationAuthenticateDuration:
        {
          int _arg0;
          _arg0 = data.readInt();
          data.enforceNoDataAvail();
          this.setOperationAuthenticateDuration(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setOperationAuthenticateError:
        {
          int _arg0;
          _arg0 = data.readInt();
          data.enforceNoDataAvail();
          this.setOperationAuthenticateError(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setOperationAuthenticateAcquired:
        {
          android.hardware.biometrics.fingerprint.virtualhal.AcquiredInfoAndVendorCode[] _arg0;
          _arg0 = data.createTypedArray(android.hardware.biometrics.fingerprint.virtualhal.AcquiredInfoAndVendorCode.CREATOR);
          data.enforceNoDataAvail();
          this.setOperationAuthenticateAcquired(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setOperationEnrollError:
        {
          int _arg0;
          _arg0 = data.readInt();
          data.enforceNoDataAvail();
          this.setOperationEnrollError(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setOperationEnrollLatency:
        {
          int[] _arg0;
          _arg0 = data.createIntArray();
          data.enforceNoDataAvail();
          this.setOperationEnrollLatency(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setOperationDetectInteractionLatency:
        {
          int[] _arg0;
          _arg0 = data.createIntArray();
          data.enforceNoDataAvail();
          this.setOperationDetectInteractionLatency(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setOperationDetectInteractionError:
        {
          int _arg0;
          _arg0 = data.readInt();
          data.enforceNoDataAvail();
          this.setOperationDetectInteractionError(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setOperationDetectInteractionDuration:
        {
          int _arg0;
          _arg0 = data.readInt();
          data.enforceNoDataAvail();
          this.setOperationDetectInteractionDuration(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setOperationDetectInteractionAcquired:
        {
          android.hardware.biometrics.fingerprint.virtualhal.AcquiredInfoAndVendorCode[] _arg0;
          _arg0 = data.createTypedArray(android.hardware.biometrics.fingerprint.virtualhal.AcquiredInfoAndVendorCode.CREATOR);
          data.enforceNoDataAvail();
          this.setOperationDetectInteractionAcquired(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setLockout:
        {
          boolean _arg0;
          _arg0 = data.readBoolean();
          data.enforceNoDataAvail();
          this.setLockout(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setLockoutEnable:
        {
          boolean _arg0;
          _arg0 = data.readBoolean();
          data.enforceNoDataAvail();
          this.setLockoutEnable(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setLockoutTimedThreshold:
        {
          int _arg0;
          _arg0 = data.readInt();
          data.enforceNoDataAvail();
          this.setLockoutTimedThreshold(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setLockoutTimedDuration:
        {
          int _arg0;
          _arg0 = data.readInt();
          data.enforceNoDataAvail();
          this.setLockoutTimedDuration(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setLockoutPermanentThreshold:
        {
          int _arg0;
          _arg0 = data.readInt();
          data.enforceNoDataAvail();
          this.setLockoutPermanentThreshold(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_resetConfigurations:
        {
          this.resetConfigurations();
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setType:
        {
          byte _arg0;
          _arg0 = data.readByte();
          data.enforceNoDataAvail();
          this.setType(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setSensorId:
        {
          int _arg0;
          _arg0 = data.readInt();
          data.enforceNoDataAvail();
          this.setSensorId(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setSensorStrength:
        {
          byte _arg0;
          _arg0 = data.readByte();
          data.enforceNoDataAvail();
          this.setSensorStrength(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setMaxEnrollmentPerUser:
        {
          int _arg0;
          _arg0 = data.readInt();
          data.enforceNoDataAvail();
          this.setMaxEnrollmentPerUser(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setSensorLocation:
        {
          android.hardware.biometrics.fingerprint.SensorLocation _arg0;
          _arg0 = data.readTypedObject(android.hardware.biometrics.fingerprint.SensorLocation.CREATOR);
          data.enforceNoDataAvail();
          this.setSensorLocation(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setNavigationGesture:
        {
          boolean _arg0;
          _arg0 = data.readBoolean();
          data.enforceNoDataAvail();
          this.setNavigationGesture(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setDetectInteraction:
        {
          boolean _arg0;
          _arg0 = data.readBoolean();
          data.enforceNoDataAvail();
          this.setDetectInteraction(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setDisplayTouch:
        {
          boolean _arg0;
          _arg0 = data.readBoolean();
          data.enforceNoDataAvail();
          this.setDisplayTouch(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setControlIllumination:
        {
          boolean _arg0;
          _arg0 = data.readBoolean();
          data.enforceNoDataAvail();
          this.setControlIllumination(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_getFingerprintHal:
        {
          android.hardware.biometrics.fingerprint.IFingerprint _result = this.getFingerprintHal();
          reply.writeNoException();
          reply.writeStrongInterface(_result);
          break;
        }
        default:
        {
          return super.onTransact(code, data, reply, flags);
        }
      }
      return true;
    }
    private static class Proxy implements android.hardware.biometrics.fingerprint.virtualhal.IVirtualHal
    {
      private android.os.IBinder mRemote;
      Proxy(android.os.IBinder remote)
      {
        mRemote = remote;
      }
      @Override public android.os.IBinder asBinder()
      {
        return mRemote;
      }
      public java.lang.String getInterfaceDescriptor()
      {
        return DESCRIPTOR;
      }
      /** Set Fingerprint Virtual HAL behavior parameters */
      /**
       * setEnrollments
       * 
       * Set the ids of the fingerprints that were currently enrolled in the Virtual HAL,
       * 
       * @param ids ids can contain 1 or more ids, each must be larger than 0
       */
      @Override public void setEnrollments(int[] id) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeIntArray(id);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setEnrollments, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setEnrollmentHit
       * 
       * Set current fingerprint enrollment ids in Fingerprint Virtual HAL,
       * 
       * @param ids ids can contain 1 or more ids, each must be larger than 0
       */
      @Override public void setEnrollmentHit(int hit_id) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeInt(hit_id);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setEnrollmentHit, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setNextEnrollment
       * 
       * Set the next enrollment behavior
       * 
       * @param next_enrollment specifies enrollment id, progress stages and final result
       */
      @Override public void setNextEnrollment(android.hardware.biometrics.fingerprint.virtualhal.NextEnrollment next_enrollment) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeTypedObject(next_enrollment, 0);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setNextEnrollment, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setAuthenticatorId
       * 
       * Set authenticator id in virtual HAL, the id is returned in ISession#getAuthenticatorId() call
       * 
       * @param id authenticator id value, only applied to the sensor with SensorStrength::STRONG.
       */
      @Override public void setAuthenticatorId(long id) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeLong(id);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setAuthenticatorId, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setChallenge
       * 
       * Set the challenge generated by the virtual HAL, which is returned in
       * ISessionCallback#onChallengeGenerated()
       * 
       * @param challenge
       */
      @Override public void setChallenge(long challenge) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeLong(challenge);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setChallenge, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setOperationAuthenticateFails
       * 
       * Set whether to force authentication to fail. If true, the virtual hal will report failure on
       * authentication attempt until it is set to false
       * 
       * @param fail  if true, then the next authentication will fail
       */
      @Override public void setOperationAuthenticateFails(boolean fail) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeBoolean(fail);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setOperationAuthenticateFails, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setOperationAuthenticateLatency
       * 
       * Set authentication latency in the virtual hal in a fixed value (single element) or random
       * values (two elements representing the bound values)
       * The latency simulates the delay from the time framework requesting HAL to authetication to
       * the time when HAL is ready to perform authentication operations.
       * 
       * This method fails with STATUS_INVALID_PARAMETERS if the passed-in array falls in any of
       * the following conditions
       *   1. the array contains no element
       *   2. the array contains more than two elements
       *   3. the array contains any negative value
       * The accompanying error message gives more detail
       * 
       * @param latencyMs[]  value(s) are in milli-seconds
       */
      @Override public void setOperationAuthenticateLatency(int[] latencyMs) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeIntArray(latencyMs);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setOperationAuthenticateLatency, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setOperationAuthenticateDuration
       * 
       * Set authentication duration covering the HAL authetication from start to end, including
       * fingerprint capturing, and matching, acquired info reporting. In case a sequence of acquired
       * info code are specified via setOperationAuthenticateAcquired(), the reporting is evenly
       * distributed over the duration.
       * 
       * This method fails with STATUS_INVALID_PARAMETERS if the passed-in value is negative
       * 
       * @param duration  value is in milli-seconds
       */
      @Override public void setOperationAuthenticateDuration(int durationMs) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeInt(durationMs);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setOperationAuthenticateDuration, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setOperationAuthenticateError
       * 
       * Force authentication to error out for non-zero error
       * Check hardware/interfaces/biometrics/fingerprint/aidl/default/README.md for valid error codes
       * 
       * @param error if error < 1000
       *                  non-vendor error
       *              else
       *                  vendor error
       */
      @Override public void setOperationAuthenticateError(int error) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeInt(error);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setOperationAuthenticateError, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setOperationAuthenticateAcquired
       * 
       * Set one of more acquired info codes for the virtual hal to report during authentication
       * Check hardware/interfaces/biometrics/fingerprint/aidl/default/README.md for valid acquired
       * info codes
       * 
       * @param acquired[], one or more acquired info codes
       */
      @Override public void setOperationAuthenticateAcquired(android.hardware.biometrics.fingerprint.virtualhal.AcquiredInfoAndVendorCode[] acquired) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeTypedArray(acquired, 0);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setOperationAuthenticateAcquired, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setOperationEnrollError
       * 
       * Force enrollment operation to error out for non-zero error
       * Check hardware/interfaces/biometrics/fingerprint/aidl/default/README.md for valid error codes
       * 
       * @param error if error < 1000
       *                  non-vendor error
       *              else
       *                  vendor error
       */
      @Override public void setOperationEnrollError(int error) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeInt(error);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setOperationEnrollError, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setOperationEnrollLatency
       * 
       * Set enrollment latency in the virtual hal in a fixed value (single element) or random
       * values (two elements representing the bound values)
       * The latency simulates the delay from the time framework requesting HAL to enroll to the
       * time when HAL is ready to perform enrollment operations.
       * 
       * This method fails with STATUS_INVALID_PARAMETERS if the passed-in array falls in any of
       * the following conditions
       *   1. the array contains no element
       *   2. the array contains more than two elements
       *   3. the array contains any negative value
       * The accompanying error message gives more detail
       * 
       * @param latencyMs[]  value(s) are in milli-seconds
       */
      @Override public void setOperationEnrollLatency(int[] latencyMs) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeIntArray(latencyMs);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setOperationEnrollLatency, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setOperationDetectInteractionLatency
       * 
       * Set detect interaction latency in the virtual hal in a fixed value (single element) or random
       * values (two elements representing the bound values)
       * The latency simulates the delay from the time framework requesting HAL to detect interaction
       * to the time when HAL is ready to perform detect interaction operations.
       * 
       * This method fails with STATUS_INVALID_PARAMETERS if the passed-in array falls in any of
       * the following conditions
       *   1. the array contains no element
       *   2. the array contains more than two elements
       *   3. the array contains any negative value
       * The accompanying error message gives more detail
       * 
       * @param latencyMs[]  value(s) are in milli-seconds
       */
      @Override public void setOperationDetectInteractionLatency(int[] latencyMs) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeIntArray(latencyMs);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setOperationDetectInteractionLatency, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setOperationDetectInteractionError
       * 
       * Force detect interaction operation to error out for non-zero error
       * Check hardware/interfaces/biometrics/fingerprint/aidl/default/README.md for valid error codes
       * 
       * @param error if error < 1000
       *                  non-vendor error
       *              else
       *                  vendor error
       */
      @Override public void setOperationDetectInteractionError(int error) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeInt(error);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setOperationDetectInteractionError, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setOperationDetectInteractionDuration
       * 
       * Set detect interaction duration covering the HAL authetication from start to end, including
       * fingerprint detect and acquired info reporting. In case a sequence of acquired info code are
       * specified via setOperationDetectInteractionAcquired(), the reporting is evenly distributed
       * over the duration.
       * 
       * This method fails with STATUS_INVALID_PARAMETERS if the passed-in value is negative
       * 
       * @param duration  value is in milli-seconds
       */
      @Override public void setOperationDetectInteractionDuration(int durationMs) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeInt(durationMs);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setOperationDetectInteractionDuration, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setOperationDetectInteractionAcquired
       * 
       * Set one of more acquired info codes for the virtual hal to report during detect interaction
       * Check hardware/interfaces/biometrics/fingerprint/aidl/default/README.md for valid acquired
       * info codes
       * 
       * @param acquired[], one or more acquired info codes
       */
      @Override public void setOperationDetectInteractionAcquired(android.hardware.biometrics.fingerprint.virtualhal.AcquiredInfoAndVendorCode[] acquired) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeTypedArray(acquired, 0);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setOperationDetectInteractionAcquired, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setLockout
       * 
       * Whether to force to lockout on authentcation operation. If true, the virtual hal will report
       * permanent lockout in processing authentication requrest, regardless of whether
       * setLockoutEnable(true) is called or not.
       * 
       * @param lockout, set to true if lockout is desired
       */
      @Override public void setLockout(boolean lockout) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeBoolean(lockout);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setLockout, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setLockoutEnable
       * 
       * Whether to enable authentication-fail-based lockout tracking or not. The lock tracking
       * includes both timed-based (aka temporary) lockout and permanent lockout.
       * 
       * @param enable, set true to enable the lockout tracking
       */
      @Override public void setLockoutEnable(boolean enable) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeBoolean(enable);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setLockoutEnable, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setLockoutTimedThreshold
       * 
       * Set the number of consecutive authentication failures that triggers the timed-based lock to
       * occur
       * 
       * This method fails with STATUS_INVALID_PARAMETERS if the passed-in value is negative
       * 
       * @param threshold, the number of consecutive failures
       */
      @Override public void setLockoutTimedThreshold(int threshold) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeInt(threshold);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setLockoutTimedThreshold, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setLockoutTimedDuration
       * 
       * Set the duration to expire timed-based lock during which there is no authentication failure
       * 
       * This method fails with STATUS_INVALID_PARAMETERS if the passed-in value is negative
       * 
       * @param duration, in milli-seconds
       */
      @Override public void setLockoutTimedDuration(int durationMs) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeInt(durationMs);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setLockoutTimedDuration, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setLockoutPermanentThreshold
       * 
       * Set the number of consecutive authentication failures that triggers the permanent lock to
       * occur
       * 
       * This method fails with STATUS_INVALID_PARAMETERS if the passed-in value is negative
       * 
       * @param threshold, the number of consecutive failures
       */
      @Override public void setLockoutPermanentThreshold(int threshold) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeInt(threshold);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setLockoutPermanentThreshold, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * resetConfigurations
       * 
       * Reset all virtual hal configurations to default values
       */
      @Override public void resetConfigurations() throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          boolean _status = mRemote.transact(Stub.TRANSACTION_resetConfigurations, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * The following functions are used to configure Fingerprint Virtual HAL sensor properties
       *  refer to SensorProps.aidl and CommonProps.aidl for details of each property
       */
      @Override public void setType(byte type) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeByte(type);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setType, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      @Override public void setSensorId(int id) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeInt(id);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setSensorId, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      @Override public void setSensorStrength(byte strength) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeByte(strength);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setSensorStrength, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      @Override public void setMaxEnrollmentPerUser(int max) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeInt(max);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setMaxEnrollmentPerUser, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      @Override public void setSensorLocation(android.hardware.biometrics.fingerprint.SensorLocation loc) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeTypedObject(loc, 0);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setSensorLocation, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      @Override public void setNavigationGesture(boolean v) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeBoolean(v);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setNavigationGesture, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      @Override public void setDetectInteraction(boolean v) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeBoolean(v);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setDetectInteraction, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      @Override public void setDisplayTouch(boolean v) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeBoolean(v);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setDisplayTouch, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      @Override public void setControlIllumination(boolean v) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeBoolean(v);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setControlIllumination, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      @Override public android.hardware.biometrics.fingerprint.IFingerprint getFingerprintHal() throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        android.hardware.biometrics.fingerprint.IFingerprint _result;
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          boolean _status = mRemote.transact(Stub.TRANSACTION_getFingerprintHal, _data, _reply, 0);
          _reply.readException();
          _result = android.hardware.biometrics.fingerprint.IFingerprint.Stub.asInterface(_reply.readStrongBinder());
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
        return _result;
      }
    }
    static final int TRANSACTION_setEnrollments = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);
    static final int TRANSACTION_setEnrollmentHit = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);
    static final int TRANSACTION_setNextEnrollment = (android.os.IBinder.FIRST_CALL_TRANSACTION + 2);
    static final int TRANSACTION_setAuthenticatorId = (android.os.IBinder.FIRST_CALL_TRANSACTION + 3);
    static final int TRANSACTION_setChallenge = (android.os.IBinder.FIRST_CALL_TRANSACTION + 4);
    static final int TRANSACTION_setOperationAuthenticateFails = (android.os.IBinder.FIRST_CALL_TRANSACTION + 5);
    static final int TRANSACTION_setOperationAuthenticateLatency = (android.os.IBinder.FIRST_CALL_TRANSACTION + 6);
    static final int TRANSACTION_setOperationAuthenticateDuration = (android.os.IBinder.FIRST_CALL_TRANSACTION + 7);
    static final int TRANSACTION_setOperationAuthenticateError = (android.os.IBinder.FIRST_CALL_TRANSACTION + 8);
    static final int TRANSACTION_setOperationAuthenticateAcquired = (android.os.IBinder.FIRST_CALL_TRANSACTION + 9);
    static final int TRANSACTION_setOperationEnrollError = (android.os.IBinder.FIRST_CALL_TRANSACTION + 10);
    static final int TRANSACTION_setOperationEnrollLatency = (android.os.IBinder.FIRST_CALL_TRANSACTION + 11);
    static final int TRANSACTION_setOperationDetectInteractionLatency = (android.os.IBinder.FIRST_CALL_TRANSACTION + 12);
    static final int TRANSACTION_setOperationDetectInteractionError = (android.os.IBinder.FIRST_CALL_TRANSACTION + 13);
    static final int TRANSACTION_setOperationDetectInteractionDuration = (android.os.IBinder.FIRST_CALL_TRANSACTION + 14);
    static final int TRANSACTION_setOperationDetectInteractionAcquired = (android.os.IBinder.FIRST_CALL_TRANSACTION + 15);
    static final int TRANSACTION_setLockout = (android.os.IBinder.FIRST_CALL_TRANSACTION + 16);
    static final int TRANSACTION_setLockoutEnable = (android.os.IBinder.FIRST_CALL_TRANSACTION + 17);
    static final int TRANSACTION_setLockoutTimedThreshold = (android.os.IBinder.FIRST_CALL_TRANSACTION + 18);
    static final int TRANSACTION_setLockoutTimedDuration = (android.os.IBinder.FIRST_CALL_TRANSACTION + 19);
    static final int TRANSACTION_setLockoutPermanentThreshold = (android.os.IBinder.FIRST_CALL_TRANSACTION + 20);
    static final int TRANSACTION_resetConfigurations = (android.os.IBinder.FIRST_CALL_TRANSACTION + 21);
    static final int TRANSACTION_setType = (android.os.IBinder.FIRST_CALL_TRANSACTION + 22);
    static final int TRANSACTION_setSensorId = (android.os.IBinder.FIRST_CALL_TRANSACTION + 23);
    static final int TRANSACTION_setSensorStrength = (android.os.IBinder.FIRST_CALL_TRANSACTION + 24);
    static final int TRANSACTION_setMaxEnrollmentPerUser = (android.os.IBinder.FIRST_CALL_TRANSACTION + 25);
    static final int TRANSACTION_setSensorLocation = (android.os.IBinder.FIRST_CALL_TRANSACTION + 26);
    static final int TRANSACTION_setNavigationGesture = (android.os.IBinder.FIRST_CALL_TRANSACTION + 27);
    static final int TRANSACTION_setDetectInteraction = (android.os.IBinder.FIRST_CALL_TRANSACTION + 28);
    static final int TRANSACTION_setDisplayTouch = (android.os.IBinder.FIRST_CALL_TRANSACTION + 29);
    static final int TRANSACTION_setControlIllumination = (android.os.IBinder.FIRST_CALL_TRANSACTION + 30);
    static final int TRANSACTION_getFingerprintHal = (android.os.IBinder.FIRST_CALL_TRANSACTION + 31);
    /** @hide */
    public int getMaxTransactionId()
    {
      return 31;
    }
  }
  /** @hide */
  public static final java.lang.String DESCRIPTOR = "android.hardware.biometrics.fingerprint.virtualhal.IVirtualHal";
  /**
   * The operation failed due to invalid input parameters, the error messages should
   * gives more details
   */
  public static final int STATUS_INVALID_PARAMETER = 1;
  /** Set Fingerprint Virtual HAL behavior parameters */
  /**
   * setEnrollments
   * 
   * Set the ids of the fingerprints that were currently enrolled in the Virtual HAL,
   * 
   * @param ids ids can contain 1 or more ids, each must be larger than 0
   */
  public void setEnrollments(int[] id) throws android.os.RemoteException;
  /**
   * setEnrollmentHit
   * 
   * Set current fingerprint enrollment ids in Fingerprint Virtual HAL,
   * 
   * @param ids ids can contain 1 or more ids, each must be larger than 0
   */
  public void setEnrollmentHit(int hit_id) throws android.os.RemoteException;
  /**
   * setNextEnrollment
   * 
   * Set the next enrollment behavior
   * 
   * @param next_enrollment specifies enrollment id, progress stages and final result
   */
  public void setNextEnrollment(android.hardware.biometrics.fingerprint.virtualhal.NextEnrollment next_enrollment) throws android.os.RemoteException;
  /**
   * setAuthenticatorId
   * 
   * Set authenticator id in virtual HAL, the id is returned in ISession#getAuthenticatorId() call
   * 
   * @param id authenticator id value, only applied to the sensor with SensorStrength::STRONG.
   */
  public void setAuthenticatorId(long id) throws android.os.RemoteException;
  /**
   * setChallenge
   * 
   * Set the challenge generated by the virtual HAL, which is returned in
   * ISessionCallback#onChallengeGenerated()
   * 
   * @param challenge
   */
  public void setChallenge(long challenge) throws android.os.RemoteException;
  /**
   * setOperationAuthenticateFails
   * 
   * Set whether to force authentication to fail. If true, the virtual hal will report failure on
   * authentication attempt until it is set to false
   * 
   * @param fail  if true, then the next authentication will fail
   */
  public void setOperationAuthenticateFails(boolean fail) throws android.os.RemoteException;
  /**
   * setOperationAuthenticateLatency
   * 
   * Set authentication latency in the virtual hal in a fixed value (single element) or random
   * values (two elements representing the bound values)
   * The latency simulates the delay from the time framework requesting HAL to authetication to
   * the time when HAL is ready to perform authentication operations.
   * 
   * This method fails with STATUS_INVALID_PARAMETERS if the passed-in array falls in any of
   * the following conditions
   *   1. the array contains no element
   *   2. the array contains more than two elements
   *   3. the array contains any negative value
   * The accompanying error message gives more detail
   * 
   * @param latencyMs[]  value(s) are in milli-seconds
   */
  public void setOperationAuthenticateLatency(int[] latencyMs) throws android.os.RemoteException;
  /**
   * setOperationAuthenticateDuration
   * 
   * Set authentication duration covering the HAL authetication from start to end, including
   * fingerprint capturing, and matching, acquired info reporting. In case a sequence of acquired
   * info code are specified via setOperationAuthenticateAcquired(), the reporting is evenly
   * distributed over the duration.
   * 
   * This method fails with STATUS_INVALID_PARAMETERS if the passed-in value is negative
   * 
   * @param duration  value is in milli-seconds
   */
  public void setOperationAuthenticateDuration(int durationMs) throws android.os.RemoteException;
  /**
   * setOperationAuthenticateError
   * 
   * Force authentication to error out for non-zero error
   * Check hardware/interfaces/biometrics/fingerprint/aidl/default/README.md for valid error codes
   * 
   * @param error if error < 1000
   *                  non-vendor error
   *              else
   *                  vendor error
   */
  public void setOperationAuthenticateError(int error) throws android.os.RemoteException;
  /**
   * setOperationAuthenticateAcquired
   * 
   * Set one of more acquired info codes for the virtual hal to report during authentication
   * Check hardware/interfaces/biometrics/fingerprint/aidl/default/README.md for valid acquired
   * info codes
   * 
   * @param acquired[], one or more acquired info codes
   */
  public void setOperationAuthenticateAcquired(android.hardware.biometrics.fingerprint.virtualhal.AcquiredInfoAndVendorCode[] acquired) throws android.os.RemoteException;
  /**
   * setOperationEnrollError
   * 
   * Force enrollment operation to error out for non-zero error
   * Check hardware/interfaces/biometrics/fingerprint/aidl/default/README.md for valid error codes
   * 
   * @param error if error < 1000
   *                  non-vendor error
   *              else
   *                  vendor error
   */
  public void setOperationEnrollError(int error) throws android.os.RemoteException;
  /**
   * setOperationEnrollLatency
   * 
   * Set enrollment latency in the virtual hal in a fixed value (single element) or random
   * values (two elements representing the bound values)
   * The latency simulates the delay from the time framework requesting HAL to enroll to the
   * time when HAL is ready to perform enrollment operations.
   * 
   * This method fails with STATUS_INVALID_PARAMETERS if the passed-in array falls in any of
   * the following conditions
   *   1. the array contains no element
   *   2. the array contains more than two elements
   *   3. the array contains any negative value
   * The accompanying error message gives more detail
   * 
   * @param latencyMs[]  value(s) are in milli-seconds
   */
  public void setOperationEnrollLatency(int[] latencyMs) throws android.os.RemoteException;
  /**
   * setOperationDetectInteractionLatency
   * 
   * Set detect interaction latency in the virtual hal in a fixed value (single element) or random
   * values (two elements representing the bound values)
   * The latency simulates the delay from the time framework requesting HAL to detect interaction
   * to the time when HAL is ready to perform detect interaction operations.
   * 
   * This method fails with STATUS_INVALID_PARAMETERS if the passed-in array falls in any of
   * the following conditions
   *   1. the array contains no element
   *   2. the array contains more than two elements
   *   3. the array contains any negative value
   * The accompanying error message gives more detail
   * 
   * @param latencyMs[]  value(s) are in milli-seconds
   */
  public void setOperationDetectInteractionLatency(int[] latencyMs) throws android.os.RemoteException;
  /**
   * setOperationDetectInteractionError
   * 
   * Force detect interaction operation to error out for non-zero error
   * Check hardware/interfaces/biometrics/fingerprint/aidl/default/README.md for valid error codes
   * 
   * @param error if error < 1000
   *                  non-vendor error
   *              else
   *                  vendor error
   */
  public void setOperationDetectInteractionError(int error) throws android.os.RemoteException;
  /**
   * setOperationDetectInteractionDuration
   * 
   * Set detect interaction duration covering the HAL authetication from start to end, including
   * fingerprint detect and acquired info reporting. In case a sequence of acquired info code are
   * specified via setOperationDetectInteractionAcquired(), the reporting is evenly distributed
   * over the duration.
   * 
   * This method fails with STATUS_INVALID_PARAMETERS if the passed-in value is negative
   * 
   * @param duration  value is in milli-seconds
   */
  public void setOperationDetectInteractionDuration(int durationMs) throws android.os.RemoteException;
  /**
   * setOperationDetectInteractionAcquired
   * 
   * Set one of more acquired info codes for the virtual hal to report during detect interaction
   * Check hardware/interfaces/biometrics/fingerprint/aidl/default/README.md for valid acquired
   * info codes
   * 
   * @param acquired[], one or more acquired info codes
   */
  public void setOperationDetectInteractionAcquired(android.hardware.biometrics.fingerprint.virtualhal.AcquiredInfoAndVendorCode[] acquired) throws android.os.RemoteException;
  /**
   * setLockout
   * 
   * Whether to force to lockout on authentcation operation. If true, the virtual hal will report
   * permanent lockout in processing authentication requrest, regardless of whether
   * setLockoutEnable(true) is called or not.
   * 
   * @param lockout, set to true if lockout is desired
   */
  public void setLockout(boolean lockout) throws android.os.RemoteException;
  /**
   * setLockoutEnable
   * 
   * Whether to enable authentication-fail-based lockout tracking or not. The lock tracking
   * includes both timed-based (aka temporary) lockout and permanent lockout.
   * 
   * @param enable, set true to enable the lockout tracking
   */
  public void setLockoutEnable(boolean enable) throws android.os.RemoteException;
  /**
   * setLockoutTimedThreshold
   * 
   * Set the number of consecutive authentication failures that triggers the timed-based lock to
   * occur
   * 
   * This method fails with STATUS_INVALID_PARAMETERS if the passed-in value is negative
   * 
   * @param threshold, the number of consecutive failures
   */
  public void setLockoutTimedThreshold(int threshold) throws android.os.RemoteException;
  /**
   * setLockoutTimedDuration
   * 
   * Set the duration to expire timed-based lock during which there is no authentication failure
   * 
   * This method fails with STATUS_INVALID_PARAMETERS if the passed-in value is negative
   * 
   * @param duration, in milli-seconds
   */
  public void setLockoutTimedDuration(int durationMs) throws android.os.RemoteException;
  /**
   * setLockoutPermanentThreshold
   * 
   * Set the number of consecutive authentication failures that triggers the permanent lock to
   * occur
   * 
   * This method fails with STATUS_INVALID_PARAMETERS if the passed-in value is negative
   * 
   * @param threshold, the number of consecutive failures
   */
  public void setLockoutPermanentThreshold(int threshold) throws android.os.RemoteException;
  /**
   * resetConfigurations
   * 
   * Reset all virtual hal configurations to default values
   */
  public void resetConfigurations() throws android.os.RemoteException;
  /**
   * The following functions are used to configure Fingerprint Virtual HAL sensor properties
   *  refer to SensorProps.aidl and CommonProps.aidl for details of each property
   */
  public void setType(byte type) throws android.os.RemoteException;
  public void setSensorId(int id) throws android.os.RemoteException;
  public void setSensorStrength(byte strength) throws android.os.RemoteException;
  public void setMaxEnrollmentPerUser(int max) throws android.os.RemoteException;
  public void setSensorLocation(android.hardware.biometrics.fingerprint.SensorLocation loc) throws android.os.RemoteException;
  public void setNavigationGesture(boolean v) throws android.os.RemoteException;
  public void setDetectInteraction(boolean v) throws android.os.RemoteException;
  public void setDisplayTouch(boolean v) throws android.os.RemoteException;
  public void setControlIllumination(boolean v) throws android.os.RemoteException;
  public android.hardware.biometrics.fingerprint.IFingerprint getFingerprintHal() throws android.os.RemoteException;
}
