/*
 * This file is auto-generated.  DO NOT MODIFY.
 * Using: out/host/linux-x86/bin/aidl --lang=java -Weverything -Wno-missing-permission-annotation -t --min_sdk_version platform_apis -pout/soong/.intermediates/hardware/interfaces/biometrics/common/aidl/android.hardware.biometrics.common_interface/4/preprocessed.aidl -pout/soong/.intermediates/hardware/interfaces/keymaster/aidl/android.hardware.keymaster_interface/4/preprocessed.aidl -pout/soong/.intermediates/hardware/interfaces/biometrics/face/aidl/android.hardware.biometrics.face_interface/4/preprocessed.aidl --ninja -d out/soong/.intermediates/hardware/interfaces/biometrics/face/aidl/android.hardware.biometrics.face.virtualhal-java-source/gen/android/hardware/biometrics/face/virtualhal/IVirtualHal.java.d -o out/soong/.intermediates/hardware/interfaces/biometrics/face/aidl/android.hardware.biometrics.face.virtualhal-java-source/gen -Nhardware/interfaces/biometrics/face/aidl hardware/interfaces/biometrics/face/aidl/android/hardware/biometrics/face/virtualhal/IVirtualHal.aidl
 *
 * DO NOT CHECK THIS FILE INTO A CODE TREE (e.g. git, etc..).
 * ALWAYS GENERATE THIS FILE FROM UPDATED AIDL COMPILER
 * AS A BUILD INTERMEDIATE ONLY. THIS IS NOT SOURCE CODE.
 */
package android.hardware.biometrics.face.virtualhal;
/** @hide */
public interface IVirtualHal extends android.os.IInterface
{
  /** Default implementation for IVirtualHal. */
  public static class Default implements android.hardware.biometrics.face.virtualhal.IVirtualHal
  {
    /** Set Face Virtual HAL behavior parameters */
    /**
     * setEnrollments
     * 
     * Set the ids of the faces that were currently enrolled in the Virtual HAL,
     * 
     * @param ids ids can contain 1 or more ids, each must be larger than 0
     */
    @Override public void setEnrollments(int[] id) throws android.os.RemoteException
    {
    }
    /**
     * setEnrollmentHit
     * 
     * Set current face enrollment ids in Face Virtual HAL,
     * 
     * @param ids ids can contain 1 or more ids, each must be larger than 0
     */
    @Override public void setEnrollmentHit(int hit_id) throws android.os.RemoteException
    {
    }
    /**
     * setNextEnrollment
     * 
     * Set the next enrollment behavior
     * 
     * @param next_enrollment specifies enrollment id, progress stages and final result
     */
    @Override public void setNextEnrollment(android.hardware.biometrics.face.virtualhal.NextEnrollment next_enrollment) throws android.os.RemoteException
    {
    }
    /**
     * setAuthenticatorId
     * 
     * Set authenticator id in virtual HAL, the id is returned in ISession#AuthenticatorId() call
     * 
     * @param id authenticator id value, only applied to the sensor with SensorStrength::STRONG.
     */
    @Override public void setAuthenticatorId(long id) throws android.os.RemoteException
    {
    }
    /**
     * setChallenge
     * 
     * Set the challenge generated by the virtual HAL, which is returned in
     * ISessionCallback#onChallengeGenerated()
     * 
     * @param challenge
     */
    @Override public void setChallenge(long challenge) throws android.os.RemoteException
    {
    }
    /**
     * setOperationAuthenticateFails
     * 
     * Set whether to force authentication to fail. If true, the virtual hal will report failure on
     * authentication attempt until it is set to false
     * 
     * @param fail  if true, then the next authentication will fail
     */
    @Override public void setOperationAuthenticateFails(boolean fail) throws android.os.RemoteException
    {
    }
    /**
     * setOperationAuthenticateLatency
     * 
     * Set authentication latency in the virtual hal in a fixed value (single element) or random
     * values (two elements representing the bound values)
     * The latency simulates the delay from the time framework requesting HAL to authetication to
     * the time when HAL is ready to perform authentication operations.
     * 
     * This method fails with STATUS_INVALID_PARAMETERS if the passed-in array falls in any of
     * the following conditions
     *   1. the array contains no element
     *   2. the array contains more than two elements
     *   3. the array contains any negative value
     * The accompanying error message gives more detail
     * 
     * @param latencyMs[]  value(s) are in milli-seconds
     */
    @Override public void setOperationAuthenticateLatency(int[] latencyMs) throws android.os.RemoteException
    {
    }
    /**
     * setOperationAuthenticateDuration
     * 
     * Set authentication duration covering the HAL authetication from start to end, including
     * face capturing, and matching, acquired info reporting. In case a sequence of acquired
     * info code are specified via setOperationAuthenticateAcquired(), the reporting is evenly
     * distributed over the duration.
     * 
     * This method fails with STATUS_INVALID_PARAMETERS if the passed-in value is negative
     * 
     * @param duration  value is in milli-seconds
     */
    @Override public void setOperationAuthenticateDuration(int durationMs) throws android.os.RemoteException
    {
    }
    /**
     * setOperationAuthenticateError
     * 
     * Force authentication to error out for non-zero error
     * Check
     * hardware/interfaces/biometrics/face/aidl/default/aidl/android/hardware/biometrics/face/Error.aidl
     * for valid error codes
     * 
     * @param error if error < 1000
     *                  non-vendor error
     *              else
     *                  vendor error
     */
    @Override public void setOperationAuthenticateError(int error) throws android.os.RemoteException
    {
    }
    /**
     * setOperationAuthenticateAcquired
     * 
     * Set one of more acquired info codes for the virtual hal to report during authentication
     * Check
     * hardware/interfaces/biometrics/face/aidl/aidl/android/hardware/biometrics/face/AcquiredInfo.aidl
     * for valid acquired info codes
     * 
     * @param acquired[], one or more acquired info codes
     */
    @Override public void setOperationAuthenticateAcquired(android.hardware.biometrics.face.virtualhal.AcquiredInfoAndVendorCode[] acquired) throws android.os.RemoteException
    {
    }
    /**
     * setOperationEnrollLatency
     * 
     * Set enrollment latency in the virtual hal in a fixed value (single element) or random
     * values (two elements representing the bound values)
     * The latency simulates the delay from the time framework requesting HAL to enroll to the
     * time when HAL is ready to perform enrollment operations.
     * 
     * This method fails with STATUS_INVALID_PARAMETERS if the passed-in array falls in any of
     * the following conditions
     *   1. the array contains no element
     *   2. the array contains more than two elements
     *   3. the array contains any negative value
     * The accompanying error message gives more detail
     * 
     * @param latencyMs[]  value(s) are in milli-seconds
     */
    @Override public void setOperationEnrollLatency(int[] latencyMs) throws android.os.RemoteException
    {
    }
    /**
     * setOperationDetectInteractionLatency
     * 
     * Set detect interaction latency in the virtual hal in a fixed value (single element) or random
     * values (two elements representing the bound values)
     * The latency simulates the delay from the time framework requesting HAL to detect interaction
     * to the time when HAL is ready to perform detect interaction operations.
     * 
     * This method fails with STATUS_INVALID_PARAMETERS if the passed-in array falls in any of
     * the following conditions
     *   1. the array contains no element
     *   2. the array contains more than two elements
     *   3. the array contains any negative value
     * The accompanying error message gives more detail
     * 
     * @param latencyMs[]  value(s) are in milli-seconds
     */
    @Override public void setOperationDetectInteractionLatency(int[] latencyMs) throws android.os.RemoteException
    {
    }
    /**
     * setOperationDetectInteractionFails
     * 
     * Force detect interaction operation to fail
     */
    @Override public void setOperationDetectInteractionFails(boolean error) throws android.os.RemoteException
    {
    }
    /**
     * setLockout
     * 
     * Whether to force to lockout on authentcation operation. If true, the virtual hal will report
     * permanent lockout in processing authentication requrest, regardless of whether
     * setLockoutEnable(true) is called or not.
     * 
     * @param lockout, set to true if lockout is desired
     */
    @Override public void setLockout(boolean lockout) throws android.os.RemoteException
    {
    }
    /**
     * setLockoutEnable
     * 
     * Whether to enable authentication-fail-based lockout tracking or not. The lock tracking
     * includes both timed-based (aka temporary) lockout and permanent lockout.
     * 
     * @param enable, set true to enable the lockout tracking
     */
    @Override public void setLockoutEnable(boolean enable) throws android.os.RemoteException
    {
    }
    /**
     * setLockoutTimedEnable
     * 
     * Whether to enable authentication-fail-based time-based-lockout tracking or not.
     * 
     * @param enable, set true to enable the time-basedlockout tracking
     */
    @Override public void setLockoutTimedEnable(boolean enable) throws android.os.RemoteException
    {
    }
    /**
     * setLockoutTimedThreshold
     * 
     * Set the number of consecutive authentication failures that triggers the timed-based lock to
     * occur
     * 
     * This method fails with STATUS_INVALID_PARAMETERS if the passed-in value is negative
     * 
     * @param threshold, the number of consecutive failures
     */
    @Override public void setLockoutTimedThreshold(int threshold) throws android.os.RemoteException
    {
    }
    /**
     * setLockoutTimedDuration
     * 
     * Set the duration to expire timed-based lock during which there is no authentication failure
     * 
     * This method fails with STATUS_INVALID_PARAMETERS if the passed-in value is negative
     * 
     * @param duration, in milli-seconds
     */
    @Override public void setLockoutTimedDuration(int durationMs) throws android.os.RemoteException
    {
    }
    /**
     * setLockoutPermanentThreshold
     * 
     * Set the number of consecutive authentication failures that triggers the permanent lock to
     * occur
     * 
     * This method fails with STATUS_INVALID_PARAMETERS if the passed-in value is negative
     * 
     * @param threshold, the number of consecutive failures
     */
    @Override public void setLockoutPermanentThreshold(int threshold) throws android.os.RemoteException
    {
    }
    /**
     * resetConfigurations
     * 
     * Reset all virtual hal configurations to default values
     */
    @Override public void resetConfigurations() throws android.os.RemoteException
    {
    }
    /**
     * setType
     * 
     * Configure virtual face sensor type
     * 
     * @param type, sensor type as specified in FaceSensorType.aidl
     */
    @Override public void setType(byte type) throws android.os.RemoteException
    {
    }
    /**
     *  setSensorStrength
     * 
     *  Configure virtual face sensor strength
     * 
     * @param sensor strength as specified in common/SensorStrength.aidl
     */
    @Override public void setSensorStrength(byte strength) throws android.os.RemoteException
    {
    }
    /**
     * getFaceHal
     * 
     * @return IFace interface associated with IVirtualHal instance
     */
    @Override public android.hardware.biometrics.face.IFace getFaceHal() throws android.os.RemoteException
    {
      return null;
    }
    @Override
    public android.os.IBinder asBinder() {
      return null;
    }
  }
  /** Local-side IPC implementation stub class. */
  public static abstract class Stub extends android.os.Binder implements android.hardware.biometrics.face.virtualhal.IVirtualHal
  {
    /** Construct the stub and attach it to the interface. */
    @SuppressWarnings("this-escape")
    public Stub()
    {
      this.attachInterface(this, DESCRIPTOR);
    }
    /**
     * Cast an IBinder object into an android.hardware.biometrics.face.virtualhal.IVirtualHal interface,
     * generating a proxy if needed.
     */
    public static android.hardware.biometrics.face.virtualhal.IVirtualHal asInterface(android.os.IBinder obj)
    {
      if ((obj==null)) {
        return null;
      }
      android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
      if (((iin!=null)&&(iin instanceof android.hardware.biometrics.face.virtualhal.IVirtualHal))) {
        return ((android.hardware.biometrics.face.virtualhal.IVirtualHal)iin);
      }
      return new android.hardware.biometrics.face.virtualhal.IVirtualHal.Stub.Proxy(obj);
    }
    @Override public android.os.IBinder asBinder()
    {
      return this;
    }
    /** @hide */
    public static java.lang.String getDefaultTransactionName(int transactionCode)
    {
      switch (transactionCode)
      {
        case TRANSACTION_setEnrollments:
        {
          return "setEnrollments";
        }
        case TRANSACTION_setEnrollmentHit:
        {
          return "setEnrollmentHit";
        }
        case TRANSACTION_setNextEnrollment:
        {
          return "setNextEnrollment";
        }
        case TRANSACTION_setAuthenticatorId:
        {
          return "setAuthenticatorId";
        }
        case TRANSACTION_setChallenge:
        {
          return "setChallenge";
        }
        case TRANSACTION_setOperationAuthenticateFails:
        {
          return "setOperationAuthenticateFails";
        }
        case TRANSACTION_setOperationAuthenticateLatency:
        {
          return "setOperationAuthenticateLatency";
        }
        case TRANSACTION_setOperationAuthenticateDuration:
        {
          return "setOperationAuthenticateDuration";
        }
        case TRANSACTION_setOperationAuthenticateError:
        {
          return "setOperationAuthenticateError";
        }
        case TRANSACTION_setOperationAuthenticateAcquired:
        {
          return "setOperationAuthenticateAcquired";
        }
        case TRANSACTION_setOperationEnrollLatency:
        {
          return "setOperationEnrollLatency";
        }
        case TRANSACTION_setOperationDetectInteractionLatency:
        {
          return "setOperationDetectInteractionLatency";
        }
        case TRANSACTION_setOperationDetectInteractionFails:
        {
          return "setOperationDetectInteractionFails";
        }
        case TRANSACTION_setLockout:
        {
          return "setLockout";
        }
        case TRANSACTION_setLockoutEnable:
        {
          return "setLockoutEnable";
        }
        case TRANSACTION_setLockoutTimedEnable:
        {
          return "setLockoutTimedEnable";
        }
        case TRANSACTION_setLockoutTimedThreshold:
        {
          return "setLockoutTimedThreshold";
        }
        case TRANSACTION_setLockoutTimedDuration:
        {
          return "setLockoutTimedDuration";
        }
        case TRANSACTION_setLockoutPermanentThreshold:
        {
          return "setLockoutPermanentThreshold";
        }
        case TRANSACTION_resetConfigurations:
        {
          return "resetConfigurations";
        }
        case TRANSACTION_setType:
        {
          return "setType";
        }
        case TRANSACTION_setSensorStrength:
        {
          return "setSensorStrength";
        }
        case TRANSACTION_getFaceHal:
        {
          return "getFaceHal";
        }
        default:
        {
          return null;
        }
      }
    }
    /** @hide */
    public java.lang.String getTransactionName(int transactionCode)
    {
      return this.getDefaultTransactionName(transactionCode);
    }
    @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException
    {
      java.lang.String descriptor = DESCRIPTOR;
      if (code >= android.os.IBinder.FIRST_CALL_TRANSACTION && code <= android.os.IBinder.LAST_CALL_TRANSACTION) {
        data.enforceInterface(descriptor);
      }
      if (code == INTERFACE_TRANSACTION) {
        reply.writeString(descriptor);
        return true;
      }
      switch (code)
      {
        case TRANSACTION_setEnrollments:
        {
          int[] _arg0;
          _arg0 = data.createIntArray();
          data.enforceNoDataAvail();
          this.setEnrollments(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setEnrollmentHit:
        {
          int _arg0;
          _arg0 = data.readInt();
          data.enforceNoDataAvail();
          this.setEnrollmentHit(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setNextEnrollment:
        {
          android.hardware.biometrics.face.virtualhal.NextEnrollment _arg0;
          _arg0 = data.readTypedObject(android.hardware.biometrics.face.virtualhal.NextEnrollment.CREATOR);
          data.enforceNoDataAvail();
          this.setNextEnrollment(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setAuthenticatorId:
        {
          long _arg0;
          _arg0 = data.readLong();
          data.enforceNoDataAvail();
          this.setAuthenticatorId(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setChallenge:
        {
          long _arg0;
          _arg0 = data.readLong();
          data.enforceNoDataAvail();
          this.setChallenge(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setOperationAuthenticateFails:
        {
          boolean _arg0;
          _arg0 = data.readBoolean();
          data.enforceNoDataAvail();
          this.setOperationAuthenticateFails(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setOperationAuthenticateLatency:
        {
          int[] _arg0;
          _arg0 = data.createIntArray();
          data.enforceNoDataAvail();
          this.setOperationAuthenticateLatency(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setOperationAuthenticateDuration:
        {
          int _arg0;
          _arg0 = data.readInt();
          data.enforceNoDataAvail();
          this.setOperationAuthenticateDuration(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setOperationAuthenticateError:
        {
          int _arg0;
          _arg0 = data.readInt();
          data.enforceNoDataAvail();
          this.setOperationAuthenticateError(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setOperationAuthenticateAcquired:
        {
          android.hardware.biometrics.face.virtualhal.AcquiredInfoAndVendorCode[] _arg0;
          _arg0 = data.createTypedArray(android.hardware.biometrics.face.virtualhal.AcquiredInfoAndVendorCode.CREATOR);
          data.enforceNoDataAvail();
          this.setOperationAuthenticateAcquired(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setOperationEnrollLatency:
        {
          int[] _arg0;
          _arg0 = data.createIntArray();
          data.enforceNoDataAvail();
          this.setOperationEnrollLatency(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setOperationDetectInteractionLatency:
        {
          int[] _arg0;
          _arg0 = data.createIntArray();
          data.enforceNoDataAvail();
          this.setOperationDetectInteractionLatency(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setOperationDetectInteractionFails:
        {
          boolean _arg0;
          _arg0 = data.readBoolean();
          data.enforceNoDataAvail();
          this.setOperationDetectInteractionFails(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setLockout:
        {
          boolean _arg0;
          _arg0 = data.readBoolean();
          data.enforceNoDataAvail();
          this.setLockout(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setLockoutEnable:
        {
          boolean _arg0;
          _arg0 = data.readBoolean();
          data.enforceNoDataAvail();
          this.setLockoutEnable(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setLockoutTimedEnable:
        {
          boolean _arg0;
          _arg0 = data.readBoolean();
          data.enforceNoDataAvail();
          this.setLockoutTimedEnable(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setLockoutTimedThreshold:
        {
          int _arg0;
          _arg0 = data.readInt();
          data.enforceNoDataAvail();
          this.setLockoutTimedThreshold(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setLockoutTimedDuration:
        {
          int _arg0;
          _arg0 = data.readInt();
          data.enforceNoDataAvail();
          this.setLockoutTimedDuration(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setLockoutPermanentThreshold:
        {
          int _arg0;
          _arg0 = data.readInt();
          data.enforceNoDataAvail();
          this.setLockoutPermanentThreshold(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_resetConfigurations:
        {
          this.resetConfigurations();
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setType:
        {
          byte _arg0;
          _arg0 = data.readByte();
          data.enforceNoDataAvail();
          this.setType(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_setSensorStrength:
        {
          byte _arg0;
          _arg0 = data.readByte();
          data.enforceNoDataAvail();
          this.setSensorStrength(_arg0);
          reply.writeNoException();
          break;
        }
        case TRANSACTION_getFaceHal:
        {
          android.hardware.biometrics.face.IFace _result = this.getFaceHal();
          reply.writeNoException();
          reply.writeStrongInterface(_result);
          break;
        }
        default:
        {
          return super.onTransact(code, data, reply, flags);
        }
      }
      return true;
    }
    private static class Proxy implements android.hardware.biometrics.face.virtualhal.IVirtualHal
    {
      private android.os.IBinder mRemote;
      Proxy(android.os.IBinder remote)
      {
        mRemote = remote;
      }
      @Override public android.os.IBinder asBinder()
      {
        return mRemote;
      }
      public java.lang.String getInterfaceDescriptor()
      {
        return DESCRIPTOR;
      }
      /** Set Face Virtual HAL behavior parameters */
      /**
       * setEnrollments
       * 
       * Set the ids of the faces that were currently enrolled in the Virtual HAL,
       * 
       * @param ids ids can contain 1 or more ids, each must be larger than 0
       */
      @Override public void setEnrollments(int[] id) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeIntArray(id);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setEnrollments, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setEnrollmentHit
       * 
       * Set current face enrollment ids in Face Virtual HAL,
       * 
       * @param ids ids can contain 1 or more ids, each must be larger than 0
       */
      @Override public void setEnrollmentHit(int hit_id) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeInt(hit_id);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setEnrollmentHit, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setNextEnrollment
       * 
       * Set the next enrollment behavior
       * 
       * @param next_enrollment specifies enrollment id, progress stages and final result
       */
      @Override public void setNextEnrollment(android.hardware.biometrics.face.virtualhal.NextEnrollment next_enrollment) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeTypedObject(next_enrollment, 0);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setNextEnrollment, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setAuthenticatorId
       * 
       * Set authenticator id in virtual HAL, the id is returned in ISession#AuthenticatorId() call
       * 
       * @param id authenticator id value, only applied to the sensor with SensorStrength::STRONG.
       */
      @Override public void setAuthenticatorId(long id) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeLong(id);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setAuthenticatorId, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setChallenge
       * 
       * Set the challenge generated by the virtual HAL, which is returned in
       * ISessionCallback#onChallengeGenerated()
       * 
       * @param challenge
       */
      @Override public void setChallenge(long challenge) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeLong(challenge);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setChallenge, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setOperationAuthenticateFails
       * 
       * Set whether to force authentication to fail. If true, the virtual hal will report failure on
       * authentication attempt until it is set to false
       * 
       * @param fail  if true, then the next authentication will fail
       */
      @Override public void setOperationAuthenticateFails(boolean fail) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeBoolean(fail);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setOperationAuthenticateFails, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setOperationAuthenticateLatency
       * 
       * Set authentication latency in the virtual hal in a fixed value (single element) or random
       * values (two elements representing the bound values)
       * The latency simulates the delay from the time framework requesting HAL to authetication to
       * the time when HAL is ready to perform authentication operations.
       * 
       * This method fails with STATUS_INVALID_PARAMETERS if the passed-in array falls in any of
       * the following conditions
       *   1. the array contains no element
       *   2. the array contains more than two elements
       *   3. the array contains any negative value
       * The accompanying error message gives more detail
       * 
       * @param latencyMs[]  value(s) are in milli-seconds
       */
      @Override public void setOperationAuthenticateLatency(int[] latencyMs) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeIntArray(latencyMs);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setOperationAuthenticateLatency, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setOperationAuthenticateDuration
       * 
       * Set authentication duration covering the HAL authetication from start to end, including
       * face capturing, and matching, acquired info reporting. In case a sequence of acquired
       * info code are specified via setOperationAuthenticateAcquired(), the reporting is evenly
       * distributed over the duration.
       * 
       * This method fails with STATUS_INVALID_PARAMETERS if the passed-in value is negative
       * 
       * @param duration  value is in milli-seconds
       */
      @Override public void setOperationAuthenticateDuration(int durationMs) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeInt(durationMs);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setOperationAuthenticateDuration, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setOperationAuthenticateError
       * 
       * Force authentication to error out for non-zero error
       * Check
       * hardware/interfaces/biometrics/face/aidl/default/aidl/android/hardware/biometrics/face/Error.aidl
       * for valid error codes
       * 
       * @param error if error < 1000
       *                  non-vendor error
       *              else
       *                  vendor error
       */
      @Override public void setOperationAuthenticateError(int error) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeInt(error);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setOperationAuthenticateError, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setOperationAuthenticateAcquired
       * 
       * Set one of more acquired info codes for the virtual hal to report during authentication
       * Check
       * hardware/interfaces/biometrics/face/aidl/aidl/android/hardware/biometrics/face/AcquiredInfo.aidl
       * for valid acquired info codes
       * 
       * @param acquired[], one or more acquired info codes
       */
      @Override public void setOperationAuthenticateAcquired(android.hardware.biometrics.face.virtualhal.AcquiredInfoAndVendorCode[] acquired) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeTypedArray(acquired, 0);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setOperationAuthenticateAcquired, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setOperationEnrollLatency
       * 
       * Set enrollment latency in the virtual hal in a fixed value (single element) or random
       * values (two elements representing the bound values)
       * The latency simulates the delay from the time framework requesting HAL to enroll to the
       * time when HAL is ready to perform enrollment operations.
       * 
       * This method fails with STATUS_INVALID_PARAMETERS if the passed-in array falls in any of
       * the following conditions
       *   1. the array contains no element
       *   2. the array contains more than two elements
       *   3. the array contains any negative value
       * The accompanying error message gives more detail
       * 
       * @param latencyMs[]  value(s) are in milli-seconds
       */
      @Override public void setOperationEnrollLatency(int[] latencyMs) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeIntArray(latencyMs);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setOperationEnrollLatency, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setOperationDetectInteractionLatency
       * 
       * Set detect interaction latency in the virtual hal in a fixed value (single element) or random
       * values (two elements representing the bound values)
       * The latency simulates the delay from the time framework requesting HAL to detect interaction
       * to the time when HAL is ready to perform detect interaction operations.
       * 
       * This method fails with STATUS_INVALID_PARAMETERS if the passed-in array falls in any of
       * the following conditions
       *   1. the array contains no element
       *   2. the array contains more than two elements
       *   3. the array contains any negative value
       * The accompanying error message gives more detail
       * 
       * @param latencyMs[]  value(s) are in milli-seconds
       */
      @Override public void setOperationDetectInteractionLatency(int[] latencyMs) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeIntArray(latencyMs);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setOperationDetectInteractionLatency, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setOperationDetectInteractionFails
       * 
       * Force detect interaction operation to fail
       */
      @Override public void setOperationDetectInteractionFails(boolean error) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeBoolean(error);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setOperationDetectInteractionFails, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setLockout
       * 
       * Whether to force to lockout on authentcation operation. If true, the virtual hal will report
       * permanent lockout in processing authentication requrest, regardless of whether
       * setLockoutEnable(true) is called or not.
       * 
       * @param lockout, set to true if lockout is desired
       */
      @Override public void setLockout(boolean lockout) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeBoolean(lockout);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setLockout, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setLockoutEnable
       * 
       * Whether to enable authentication-fail-based lockout tracking or not. The lock tracking
       * includes both timed-based (aka temporary) lockout and permanent lockout.
       * 
       * @param enable, set true to enable the lockout tracking
       */
      @Override public void setLockoutEnable(boolean enable) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeBoolean(enable);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setLockoutEnable, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setLockoutTimedEnable
       * 
       * Whether to enable authentication-fail-based time-based-lockout tracking or not.
       * 
       * @param enable, set true to enable the time-basedlockout tracking
       */
      @Override public void setLockoutTimedEnable(boolean enable) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeBoolean(enable);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setLockoutTimedEnable, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setLockoutTimedThreshold
       * 
       * Set the number of consecutive authentication failures that triggers the timed-based lock to
       * occur
       * 
       * This method fails with STATUS_INVALID_PARAMETERS if the passed-in value is negative
       * 
       * @param threshold, the number of consecutive failures
       */
      @Override public void setLockoutTimedThreshold(int threshold) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeInt(threshold);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setLockoutTimedThreshold, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setLockoutTimedDuration
       * 
       * Set the duration to expire timed-based lock during which there is no authentication failure
       * 
       * This method fails with STATUS_INVALID_PARAMETERS if the passed-in value is negative
       * 
       * @param duration, in milli-seconds
       */
      @Override public void setLockoutTimedDuration(int durationMs) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeInt(durationMs);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setLockoutTimedDuration, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setLockoutPermanentThreshold
       * 
       * Set the number of consecutive authentication failures that triggers the permanent lock to
       * occur
       * 
       * This method fails with STATUS_INVALID_PARAMETERS if the passed-in value is negative
       * 
       * @param threshold, the number of consecutive failures
       */
      @Override public void setLockoutPermanentThreshold(int threshold) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeInt(threshold);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setLockoutPermanentThreshold, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * resetConfigurations
       * 
       * Reset all virtual hal configurations to default values
       */
      @Override public void resetConfigurations() throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          boolean _status = mRemote.transact(Stub.TRANSACTION_resetConfigurations, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * setType
       * 
       * Configure virtual face sensor type
       * 
       * @param type, sensor type as specified in FaceSensorType.aidl
       */
      @Override public void setType(byte type) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeByte(type);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setType, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       *  setSensorStrength
       * 
       *  Configure virtual face sensor strength
       * 
       * @param sensor strength as specified in common/SensorStrength.aidl
       */
      @Override public void setSensorStrength(byte strength) throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          _data.writeByte(strength);
          boolean _status = mRemote.transact(Stub.TRANSACTION_setSensorStrength, _data, _reply, 0);
          _reply.readException();
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
      }
      /**
       * getFaceHal
       * 
       * @return IFace interface associated with IVirtualHal instance
       */
      @Override public android.hardware.biometrics.face.IFace getFaceHal() throws android.os.RemoteException
      {
        android.os.Parcel _data = android.os.Parcel.obtain(asBinder());
        android.os.Parcel _reply = android.os.Parcel.obtain();
        android.hardware.biometrics.face.IFace _result;
        try {
          _data.writeInterfaceToken(DESCRIPTOR);
          boolean _status = mRemote.transact(Stub.TRANSACTION_getFaceHal, _data, _reply, 0);
          _reply.readException();
          _result = android.hardware.biometrics.face.IFace.Stub.asInterface(_reply.readStrongBinder());
        }
        finally {
          _reply.recycle();
          _data.recycle();
        }
        return _result;
      }
    }
    static final int TRANSACTION_setEnrollments = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);
    static final int TRANSACTION_setEnrollmentHit = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);
    static final int TRANSACTION_setNextEnrollment = (android.os.IBinder.FIRST_CALL_TRANSACTION + 2);
    static final int TRANSACTION_setAuthenticatorId = (android.os.IBinder.FIRST_CALL_TRANSACTION + 3);
    static final int TRANSACTION_setChallenge = (android.os.IBinder.FIRST_CALL_TRANSACTION + 4);
    static final int TRANSACTION_setOperationAuthenticateFails = (android.os.IBinder.FIRST_CALL_TRANSACTION + 5);
    static final int TRANSACTION_setOperationAuthenticateLatency = (android.os.IBinder.FIRST_CALL_TRANSACTION + 6);
    static final int TRANSACTION_setOperationAuthenticateDuration = (android.os.IBinder.FIRST_CALL_TRANSACTION + 7);
    static final int TRANSACTION_setOperationAuthenticateError = (android.os.IBinder.FIRST_CALL_TRANSACTION + 8);
    static final int TRANSACTION_setOperationAuthenticateAcquired = (android.os.IBinder.FIRST_CALL_TRANSACTION + 9);
    static final int TRANSACTION_setOperationEnrollLatency = (android.os.IBinder.FIRST_CALL_TRANSACTION + 10);
    static final int TRANSACTION_setOperationDetectInteractionLatency = (android.os.IBinder.FIRST_CALL_TRANSACTION + 11);
    static final int TRANSACTION_setOperationDetectInteractionFails = (android.os.IBinder.FIRST_CALL_TRANSACTION + 12);
    static final int TRANSACTION_setLockout = (android.os.IBinder.FIRST_CALL_TRANSACTION + 13);
    static final int TRANSACTION_setLockoutEnable = (android.os.IBinder.FIRST_CALL_TRANSACTION + 14);
    static final int TRANSACTION_setLockoutTimedEnable = (android.os.IBinder.FIRST_CALL_TRANSACTION + 15);
    static final int TRANSACTION_setLockoutTimedThreshold = (android.os.IBinder.FIRST_CALL_TRANSACTION + 16);
    static final int TRANSACTION_setLockoutTimedDuration = (android.os.IBinder.FIRST_CALL_TRANSACTION + 17);
    static final int TRANSACTION_setLockoutPermanentThreshold = (android.os.IBinder.FIRST_CALL_TRANSACTION + 18);
    static final int TRANSACTION_resetConfigurations = (android.os.IBinder.FIRST_CALL_TRANSACTION + 19);
    static final int TRANSACTION_setType = (android.os.IBinder.FIRST_CALL_TRANSACTION + 20);
    static final int TRANSACTION_setSensorStrength = (android.os.IBinder.FIRST_CALL_TRANSACTION + 21);
    static final int TRANSACTION_getFaceHal = (android.os.IBinder.FIRST_CALL_TRANSACTION + 22);
    /** @hide */
    public int getMaxTransactionId()
    {
      return 22;
    }
  }
  /** @hide */
  public static final java.lang.String DESCRIPTOR = "android.hardware.biometrics.face.virtualhal.IVirtualHal";
  /**
   * The operation failed due to invalid input parameters, the error messages should
   * gives more details
   */
  public static final int STATUS_INVALID_PARAMETER = 1;
  /** Set Face Virtual HAL behavior parameters */
  /**
   * setEnrollments
   * 
   * Set the ids of the faces that were currently enrolled in the Virtual HAL,
   * 
   * @param ids ids can contain 1 or more ids, each must be larger than 0
   */
  public void setEnrollments(int[] id) throws android.os.RemoteException;
  /**
   * setEnrollmentHit
   * 
   * Set current face enrollment ids in Face Virtual HAL,
   * 
   * @param ids ids can contain 1 or more ids, each must be larger than 0
   */
  public void setEnrollmentHit(int hit_id) throws android.os.RemoteException;
  /**
   * setNextEnrollment
   * 
   * Set the next enrollment behavior
   * 
   * @param next_enrollment specifies enrollment id, progress stages and final result
   */
  public void setNextEnrollment(android.hardware.biometrics.face.virtualhal.NextEnrollment next_enrollment) throws android.os.RemoteException;
  /**
   * setAuthenticatorId
   * 
   * Set authenticator id in virtual HAL, the id is returned in ISession#AuthenticatorId() call
   * 
   * @param id authenticator id value, only applied to the sensor with SensorStrength::STRONG.
   */
  public void setAuthenticatorId(long id) throws android.os.RemoteException;
  /**
   * setChallenge
   * 
   * Set the challenge generated by the virtual HAL, which is returned in
   * ISessionCallback#onChallengeGenerated()
   * 
   * @param challenge
   */
  public void setChallenge(long challenge) throws android.os.RemoteException;
  /**
   * setOperationAuthenticateFails
   * 
   * Set whether to force authentication to fail. If true, the virtual hal will report failure on
   * authentication attempt until it is set to false
   * 
   * @param fail  if true, then the next authentication will fail
   */
  public void setOperationAuthenticateFails(boolean fail) throws android.os.RemoteException;
  /**
   * setOperationAuthenticateLatency
   * 
   * Set authentication latency in the virtual hal in a fixed value (single element) or random
   * values (two elements representing the bound values)
   * The latency simulates the delay from the time framework requesting HAL to authetication to
   * the time when HAL is ready to perform authentication operations.
   * 
   * This method fails with STATUS_INVALID_PARAMETERS if the passed-in array falls in any of
   * the following conditions
   *   1. the array contains no element
   *   2. the array contains more than two elements
   *   3. the array contains any negative value
   * The accompanying error message gives more detail
   * 
   * @param latencyMs[]  value(s) are in milli-seconds
   */
  public void setOperationAuthenticateLatency(int[] latencyMs) throws android.os.RemoteException;
  /**
   * setOperationAuthenticateDuration
   * 
   * Set authentication duration covering the HAL authetication from start to end, including
   * face capturing, and matching, acquired info reporting. In case a sequence of acquired
   * info code are specified via setOperationAuthenticateAcquired(), the reporting is evenly
   * distributed over the duration.
   * 
   * This method fails with STATUS_INVALID_PARAMETERS if the passed-in value is negative
   * 
   * @param duration  value is in milli-seconds
   */
  public void setOperationAuthenticateDuration(int durationMs) throws android.os.RemoteException;
  /**
   * setOperationAuthenticateError
   * 
   * Force authentication to error out for non-zero error
   * Check
   * hardware/interfaces/biometrics/face/aidl/default/aidl/android/hardware/biometrics/face/Error.aidl
   * for valid error codes
   * 
   * @param error if error < 1000
   *                  non-vendor error
   *              else
   *                  vendor error
   */
  public void setOperationAuthenticateError(int error) throws android.os.RemoteException;
  /**
   * setOperationAuthenticateAcquired
   * 
   * Set one of more acquired info codes for the virtual hal to report during authentication
   * Check
   * hardware/interfaces/biometrics/face/aidl/aidl/android/hardware/biometrics/face/AcquiredInfo.aidl
   * for valid acquired info codes
   * 
   * @param acquired[], one or more acquired info codes
   */
  public void setOperationAuthenticateAcquired(android.hardware.biometrics.face.virtualhal.AcquiredInfoAndVendorCode[] acquired) throws android.os.RemoteException;
  /**
   * setOperationEnrollLatency
   * 
   * Set enrollment latency in the virtual hal in a fixed value (single element) or random
   * values (two elements representing the bound values)
   * The latency simulates the delay from the time framework requesting HAL to enroll to the
   * time when HAL is ready to perform enrollment operations.
   * 
   * This method fails with STATUS_INVALID_PARAMETERS if the passed-in array falls in any of
   * the following conditions
   *   1. the array contains no element
   *   2. the array contains more than two elements
   *   3. the array contains any negative value
   * The accompanying error message gives more detail
   * 
   * @param latencyMs[]  value(s) are in milli-seconds
   */
  public void setOperationEnrollLatency(int[] latencyMs) throws android.os.RemoteException;
  /**
   * setOperationDetectInteractionLatency
   * 
   * Set detect interaction latency in the virtual hal in a fixed value (single element) or random
   * values (two elements representing the bound values)
   * The latency simulates the delay from the time framework requesting HAL to detect interaction
   * to the time when HAL is ready to perform detect interaction operations.
   * 
   * This method fails with STATUS_INVALID_PARAMETERS if the passed-in array falls in any of
   * the following conditions
   *   1. the array contains no element
   *   2. the array contains more than two elements
   *   3. the array contains any negative value
   * The accompanying error message gives more detail
   * 
   * @param latencyMs[]  value(s) are in milli-seconds
   */
  public void setOperationDetectInteractionLatency(int[] latencyMs) throws android.os.RemoteException;
  /**
   * setOperationDetectInteractionFails
   * 
   * Force detect interaction operation to fail
   */
  public void setOperationDetectInteractionFails(boolean error) throws android.os.RemoteException;
  /**
   * setLockout
   * 
   * Whether to force to lockout on authentcation operation. If true, the virtual hal will report
   * permanent lockout in processing authentication requrest, regardless of whether
   * setLockoutEnable(true) is called or not.
   * 
   * @param lockout, set to true if lockout is desired
   */
  public void setLockout(boolean lockout) throws android.os.RemoteException;
  /**
   * setLockoutEnable
   * 
   * Whether to enable authentication-fail-based lockout tracking or not. The lock tracking
   * includes both timed-based (aka temporary) lockout and permanent lockout.
   * 
   * @param enable, set true to enable the lockout tracking
   */
  public void setLockoutEnable(boolean enable) throws android.os.RemoteException;
  /**
   * setLockoutTimedEnable
   * 
   * Whether to enable authentication-fail-based time-based-lockout tracking or not.
   * 
   * @param enable, set true to enable the time-basedlockout tracking
   */
  public void setLockoutTimedEnable(boolean enable) throws android.os.RemoteException;
  /**
   * setLockoutTimedThreshold
   * 
   * Set the number of consecutive authentication failures that triggers the timed-based lock to
   * occur
   * 
   * This method fails with STATUS_INVALID_PARAMETERS if the passed-in value is negative
   * 
   * @param threshold, the number of consecutive failures
   */
  public void setLockoutTimedThreshold(int threshold) throws android.os.RemoteException;
  /**
   * setLockoutTimedDuration
   * 
   * Set the duration to expire timed-based lock during which there is no authentication failure
   * 
   * This method fails with STATUS_INVALID_PARAMETERS if the passed-in value is negative
   * 
   * @param duration, in milli-seconds
   */
  public void setLockoutTimedDuration(int durationMs) throws android.os.RemoteException;
  /**
   * setLockoutPermanentThreshold
   * 
   * Set the number of consecutive authentication failures that triggers the permanent lock to
   * occur
   * 
   * This method fails with STATUS_INVALID_PARAMETERS if the passed-in value is negative
   * 
   * @param threshold, the number of consecutive failures
   */
  public void setLockoutPermanentThreshold(int threshold) throws android.os.RemoteException;
  /**
   * resetConfigurations
   * 
   * Reset all virtual hal configurations to default values
   */
  public void resetConfigurations() throws android.os.RemoteException;
  /**
   * setType
   * 
   * Configure virtual face sensor type
   * 
   * @param type, sensor type as specified in FaceSensorType.aidl
   */
  public void setType(byte type) throws android.os.RemoteException;
  /**
   *  setSensorStrength
   * 
   *  Configure virtual face sensor strength
   * 
   * @param sensor strength as specified in common/SensorStrength.aidl
   */
  public void setSensorStrength(byte strength) throws android.os.RemoteException;
  /**
   * getFaceHal
   * 
   * @return IFace interface associated with IVirtualHal instance
   */
  public android.hardware.biometrics.face.IFace getFaceHal() throws android.os.RemoteException;
}
